
"""
-------------------------------------------------------
Auto-Generated Program - Multi-Feature Query Processor
Generated by: generator.py
Author: Sairithik Komuravelly (Team: NoJoinZone)
Description:
    This program executes a dynamically constructed MF (Multi-Feature) query
    over the 'sales' table. It performs multiple scans to evaluate conditions
    associated with each grouping variable and computes the required aggregates
    (e.g., sum, count, avg, max, min).

    The logic is based on enhanced SQL-like processing without using joins,
    in accordance with the CS562 Project specifications and relevant research.

    Final output is printed in a formatted table containing the fields
    specified in the 'S' clause of input.json.
-------------------------------------------------------
"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv


class MFStructure:
    def __init__(self, prod):
        self.prod = prod
        self.sum_1_quant = 0
        self.sum_2_quant = 0
        self.sum_3_quant = 0

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    sales_rows = cur.fetchall()
    _global = []
    
    h_table = []
    for row in sales_rows:
        found = False
        for entry in h_table:
            if entry.prod == row['prod']:
                found = True
                for att,val in vars(entry).items():
                    if att=='sum_quant':
                        entry.sum_quant += row['quant']
                    if att=='min_quant':
                        if entry.min_quant > row['quant']:
                            entry.min_quant = row['quant']
                    if att=='max_quant':
                        if entry.max_quant < row['quant']:
                            entry.max_quant = row['quant']
                    if att=='count_quant':
                        entry.count_quant += 1
                break
        if not found:
            new_entry = MFStructure(row['prod'])
            for att,val in vars(new_entry).items():
                    if att=='sum_quant':
                        new_entry.sum_quant = row['quant']
                    if att=='min_quant':
                        new_entry.min_quant = row['quant']
                    if att=='max_quant':
                        new_entry.max_quant = row['quant']
                    if att=='count_quant':
                        new_entry.count_quant = 1
            h_table.append(new_entry)
    
    
    # Scan for grouping variable 1
    for row in sales_rows:
        if row['month'] == 1:
            for entry in h_table:
                if entry.prod == row['prod']:
                    entry.sum_1_quant += row['quant']
                    break

    # Scan for grouping variable 2
    for row in sales_rows:
        if row['prod'] == 'Ham':
            for entry in h_table:
                if entry.prod == row['prod']:
                    entry.sum_2_quant += row['quant']
                    break

    # Scan for grouping variable 3
    for row in sales_rows:
        if row['month'] == 3:
            for entry in h_table:
                if entry.prod == row['prod']:
                    entry.sum_3_quant += row['quant']
                    break

        
    for entry in h_table:
        if True:
            _global.append({
            'prod': entry.prod, 'sum_1_quant': entry.sum_1_quant, 'sum_2_quant': entry.sum_2_quant, 'sum_3_quant': entry.sum_3_quant
    })       
    
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    