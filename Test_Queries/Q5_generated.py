
"""
-------------------------------------------------------
Auto-Generated Program - Multi-Feature Query Processor
Generated by: generator.py
Author: Sairithik Komuravelly (Team: NoJoinZone)
Description:
    This program executes a dynamically constructed MF (Multi-Feature) query
    over the 'sales' table. It performs multiple scans to evaluate conditions
    associated with each grouping variable and computes the required aggregates
    (e.g., sum, count, avg, max, min).

    The logic is based on enhanced SQL-like processing without using joins,
    in accordance with the CS562 Project specifications and relevant research.

    Final output is printed in a formatted table containing the fields
    specified in the 'S' clause of input.json.
-------------------------------------------------------
"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv


class MFStructure:
    def __init__(self, cust, prod):
        self.prod = prod
        self.cust = cust
        self.count_quant = 0
        self.sum_quant = 0
        self.count_1_quant = 0
        self.sum_1_quant = 0
        self.count_2_quant = 0
        self.sum_2_quant = 0
        self.max_3_quant = 0

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    sales_rows = cur.fetchall()
    _global = []
    
    h_table = [] # Initialize empty list to store MFStructure entries for each unique group
    # First scan: populate h_table with grouping key combinations and compute 0th g.v aggregates
    for row in sales_rows:
        found = False   # Flag to check if a matching group already exists in h_table
        for entry in h_table:
            # Check if current row matches an existing group (i.e., same grouping key values)
            if entry.cust == row['cust'] and entry.prod == row['prod']:
                found = True
                # Loop through all attributes in the MFStructure object and update aggregates
                for att,val in vars(entry).items():
                    if att=='sum_quant':
                        entry.sum_quant += row['quant']
                    if att=='min_quant':
                        if entry.min_quant > row['quant']:
                            entry.min_quant = row['quant']
                    if att=='max_quant':
                        if entry.max_quant < row['quant']:
                            entry.max_quant = row['quant']
                    if att=='count_quant':
                        entry.count_quant += 1
                break   # Stop scanning once the correct group is updated
        if not found:
            # If this is a new group, create a new MFStructure entry
            new_entry = MFStructure(row['cust'], row['prod'])
            # Initialize the required aggregate fields with current row's quant value
            for att,val in vars(new_entry).items():
                    if att=='sum_quant':
                        new_entry.sum_quant = row['quant']
                    if att=='min_quant':
                        new_entry.min_quant = row['quant']
                    if att=='max_quant':
                        new_entry.max_quant = row['quant']
                    if att=='count_quant':
                        new_entry.count_quant = 1
            h_table.append(new_entry)   # Add the new group entry to the h_table
    
    # Logic to compute grouping_variable aggregates
    
    # Scan for grouping variable 1
    for row in sales_rows:
        for entry in h_table:
            if row['state'] == 'NY':
                if entry.cust == row['cust'] and entry.prod == row['prod']:
                    entry.count_1_quant += 1; entry.sum_1_quant += row['quant']
                    break

    # Scan for grouping variable 2
    for row in sales_rows:
        for entry in h_table:
            if row['state'] == 'NJ' and row['quant'] > (entry.sum_quant / entry.count_quant if entry.count_quant != 0 else 0):
                if entry.cust == row['cust'] and entry.prod == row['prod']:
                    entry.count_2_quant += 1; entry.sum_2_quant += row['quant']
                    break

    # Scan for grouping variable 3
    for row in sales_rows:
        for entry in h_table:
            if row['state'] == 'CT' and row['quant'] < (entry.sum_2_quant / entry.count_2_quant if entry.count_2_quant != 0 else 0):
                if entry.cust == row['cust'] and entry.prod == row['prod']:
                    entry.max_3_quant = max(entry.max_3_quant, row['quant'])
                    break

    # Sorting the h_table by grouping key attributes to keep output consistent   
    h_table.sort(key=lambda x: tuple(getattr(x, attr) for attr in ['cust', 'prod']))
    # Apply the final selection condition (G_condition) and prepare result for output
    for entry in h_table:
        if (entry.sum_2_quant / entry.count_2_quant if entry.count_2_quant != 0 else 0) > 500 and entry.max_3_quant > (entry.sum_quant / entry.count_quant if entry.count_quant != 0 else 0):
            _global.append({
            'cust': entry.cust, 'prod': entry.prod, 'avg_quant': (entry.sum_quant / entry.count_quant) if entry.count_quant != 0 else 0, 'sum_1_quant': entry.sum_1_quant, 'count_1_quant': entry.count_1_quant, 'avg_2_quant': (entry.sum_2_quant / entry.count_2_quant) if entry.count_2_quant != 0 else 0, 'max_3_quant': entry.max_3_quant
    })       
    
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    